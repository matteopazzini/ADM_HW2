# -*- coding: utf-8 -*-
"""AQs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sUM1rl2SHznLpHhHMzSIqzpa-YGh6g6x
"""

def supervisor_instructions(instructions):                        # We enter a function to process instructions from the supervisor
    left_shelf = []  # Inside the function, we create a list to store books on the shelf on the left side of the function
    right_shelf = [] # Inside the function, we create a list to store books on the shelf on the right side of the function
    total_amount_of_books = 0  # Enter a variable to account for the total number of books on the shelf
    keep_answers = []  # And also a list for storing responses to Type 3 instructions

    for instruction in instructions:      # Let's start parsing each instruction in order, provided in the list of instructions
        command, *params = instruction.split()
        if command == "L":
            # For "L" instructions, we add the book id to the left_shelf list, placing it to the left of the leftmost existing book
            book_id = int(params[0])
            left_shelf.append(book_id)
        elif command == "R":
            # For "R" instructions, we add the book ID to the right_shelf list, placing it to the right of the rightmost existing book
            book_id = int(params[0])
            right_shelf.append(book_id)
        elif command == "?":
            # For "?" instructions, we calculate the minimum number of books to retrieve from the left or right to make the book with the specified identifier the leftmost or rightmost book on the shelf.
            #To do this, we find the position of the book in the corresponding shelf list (or the length of the list if the book is missing) and calculate the difference between the total number of books and the number of books on the left.
            #Then the minimum of these two values is added to the list
            book_id = int(params[0])
            left_count = left_shelf.index(book_id) if book_id in left_shelf else len(left_shelf)
            right_count = len(right_shelf) - right_shelf.index(book_id) if book_id in right_shelf else len(right_shelf) + total_amount_of_books - len(left_shelf)
            keep_answers.append(min(left_count, right_count))

        total_amount_of_books += 1 #Update the total_amount_of_books variable to track the total number of books

    return keep_answers

#Enter a number that represents the number of instructions the supervisor will provide
number_of_instructions = int(input())
instructions = [input() for _ in range(number_of_instructions)] #Generate a list of instructions, where each element of the list represents one instruction
keep_answers = supervisor_instructions(instructions) # Answer the instructions

# And display responses to supervisor's instructions
for answer in keep_answers:
    print(answer)

def supervisor_instructions(instructions):                        # We enter a function to process instructions from the supervisor
    left_shelf = []  # Inside the function, we create a list to store books on the shelf on the left side of the function
    right_shelf = [] # Inside the function, we create a list to store books on the shelf on the right side of the function
    total_amount_of_books = 0  # Enter a variable to account for the total number of books on the shelf
    keep_answers = []  # And also a list for storing responses to Type 3 instructions

    for instruction in instructions:      # Let's start parsing each instruction in order, provided in the list of instructions
        command, *params = instruction.split()
        if command == "L":
            # For "L" instructions, we add the book id to the left_shelf list, placing it to the left of the leftmost existing book
            book_id = int(params[0])
            left_shelf.append(book_id)
        elif command == "R":
            # For "R" instructions, we add the book ID to the right_shelf list, placing it to the right of the rightmost existing book
            book_id = int(params[0])
            right_shelf.append(book_id)
        elif command == "?":
            # For "?" instructions, we calculate the minimum number of books to retrieve from the left or right to make the book with the specified identifier the leftmost or rightmost book on the shelf.
            #To do this, we find the position of the book in the corresponding shelf list (or the length of the list if the book is missing) and calculate the difference between the total number of books and the number of books on the left.
            #Then the minimum of these two values is added to the list
            book_id = int(params[0])
            left_count = left_shelf.index(book_id) if book_id in left_shelf else len(left_shelf)
            right_count = len(right_shelf) - right_shelf.index(book_id) if book_id in right_shelf else len(right_shelf) + total_amount_of_books - len(left_shelf)
            keep_answers.append(min(left_count, right_count))

        total_amount_of_books += 1 #Update the total_amount_of_books variable to track the total number of books

    return keep_answers

number_of_instructions = int(input()) #Enter a number that represents the number of instructions the supervisor will provide
instructions = [input() for _ in range(number_of_instructions)] #Generate a list of instructions, where each element of the list represents one instruction
keep_answers = supervisor_instructions(instructions) # Answer the instructions

# And display responses to supervisor's instructions
for answer in keep_answers:
    print(answer)

"""2.



*   Ask ChatGPT or any other LLM chatbot tool to check your code's time complexity (the Big O notation).

ChatGPT says: "The code has a time complexity of O(n) where n is the number of instructions. It efficiently processes the instructions in a linear fashion, making it a reasonably efficient algorithm for this problem."


*   Do you believe this is correct? How can you double-check it? Elaborate about your answer.

The code processes instructions linearly and the code execution time directly depends on the size of the input data, i.e. the number of instructions. This means that as the number of instructions increases, the time required to process them also increases proportionally. The time complexity of the code is thus O(n), where 'n' is the number of instructions. This property is a characteristic for algorithms with linear time complexity. It is important to note that the code processes each instruction sequentially and the instruction processing occurs only once. Therefore, as the size of the input data increases, the total execution time of all instructions will increase proportionally.

To double-check the analysis of the code's time complexity we can:
Firstly, we must understand the code to make sure that it is linear, so to make sure that the code processes each instruction once. And that operations inside loops have constant complexity. Also, there should be no nested loops or complex recursive operations in the code.
Secondly, we should test the code with large input data and observe how the execution time changes when the 'n' value increases linearly. If the execution time increases linearly, this is real evidence that the time complexity of the code is indeed O(n).
Eventually we should assume then there may be a worse scenario, but the time complexity will still be bounded by O(n). Considering these conditions, we can make sure that the analysis of time complexity is correct and corresponds to the real time performance of the code.

3.

*   Is the algorithm proposed in (1.) the optimal one to produce the required output? If not, can you suggest a better algorithm to perform the same task?

The algorithm proposed in (1.) can be better. Linear search in such lists takes time proportional to the number of books, which may be inefficient. We can use data structures such as dictionaries or sets, which provide faster searches based on book identifiers. This can significantly increase the time complexity of the code. The optimal solution is to choose efficient data structures that provide fast search and improve the overall performance of the algorithm.

1. The more optimal time complexity of the algorithm is due to the use of `left_shelf` and `right_shelf` lists to represent the left and right sides of the shelf. These lists store book identifiers, and when a book identifier is searched using `left_shelf.indexing(an_id_of_the_book)` or `right_shelf.indexing(an_id_of_the_book)`. The linear search takes time proportional to the number of items in the list. In the worst case, when a book is not found on the shelf, the search may take O(k) time, where 'k' is the number of books placed on the shelf.



2. The using of dictionaries/sets will help to provide O(1) time complexity for search operations. In case of dictionaries, keys can be book identifiers and values can be their positions on the shelf, which provides direct access.
"""